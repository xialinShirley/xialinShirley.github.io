<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Javascript学习笔记(16)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/10/16/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(16)/" class="article-date">
  <time class="dt-published" datetime="2021-10-16T08:10:26.000Z" itemprop="datePublished">2021-10-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/10/16/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(16)/">Javascript学习笔记(16)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ol>
<li><p>单线程模型指的是，JavaScript 只在一个线程上运行。</p>
</li>
<li><p>IO操作很慢时，CPU 完全可以不管 IO 操作，挂起处于等待中的任务，先运行排在后面的任务。等到 IO 操作返回了结果，再回过头，把挂起的任务继续执行下去。这种机制就是 JavaScript 内部采用的“事件循环”机制（Event Loop）。</p>
</li>
<li><p>同步任务是那些没有被引擎挂起、在主线程上排队执行的任务。只有前一个任务执行完毕，才能执行后一个任务。</p>
</li>
<li><p>异步任务是那些被引擎放在一边，不进入主线程、而进入任务队列的任务。只有引擎认为某个异步任务可以执行了，该任务（采用回调函数的形式）才会进入主线程执行。排在异步任务后面的代码，不用等待异步任务结束会马上运行，也就是说，异步任务不具有“堵塞”效应。</p>
</li>
<li><p>只要同步任务执行完了，引擎就会去检查那些挂起来的异步任务，是不是可以进入主线程了。这种循环检查的机制，就叫做事件循环（Event Loop）。</p>
</li>
<li><p>异步任务的写法通常是回调函数。一旦异步任务重新进入主线程，就会执行对应的回调函数。如果一个异步任务没有回调函数，就不会进入任务队列。</p>
</li>
<li><p>异步操作的模式 ：</p>
<ul>
<li>回调函数 ：回调函数的优点是简单、容易理解和实现，缺点是不利于代码的阅读和维护，各个部分之间高度<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Coupling_(computer_programming)">耦合</a>（coupling），使得程序结构混乱、流程难以追踪（尤其是多个回调函数嵌套的情况），而且每个任务只能指定一个回调函数。</li>
<li>事件监听 ：异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生。这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Decoupling">去耦合</a>”（decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。阅读代码的时候，很难看出主流程。</li>
<li>发布/订阅：事件完全可以理解成“信号”，如果存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Publish-subscribe_pattern">发布/订阅模式</a>”（publish-subscribe pattern），又称“<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Observer_pattern">观察者模式</a>”（observer pattern）</li>
</ul>
</li>
<li><p>并行执行的效率较高，比起串行执行一次只能执行一个任务，较为节约时间。但是问题在于如果并行的任务较多，很容易耗尽系统资源，拖慢运行速度。因此有了第三种流程控制方式。</p>
</li>
<li><p>所谓并行与串行的结合，就是设置一个门槛，每次最多只能并行执行<code>n</code>个异步任务，这样就避免了过分占用系统资源。</p>
</li>
<li><p><code>setTimeout</code>函数用来指定某个函数或某段代码，在多少毫秒之后执行。它返回一个整数，表示定时器的编号，以后可以用来取消这个定时器。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timerId = <span class="built_in">setTimeout</span>(func|code, delay);</span><br></pre></td></tr></table></figure></li>
<li><p><code>setTimeout</code>的第二个参数如果省略，则默认为0。除了前两个参数，<code>setTimeout</code>还允许更多的参数。它们将依次传入推迟执行的函数（回调函数）。</p>
</li>
<li><p>如果回调函数是对象的方法，那么<code>setTimeout</code>使得方法内部的<code>this</code>关键字指向全局环境，而不是定义时所在的那个对象。为了防止出现这个问题:</p>
<ul>
<li>一种解决方法是将<code>obj.y</code>放入一个函数。</li>
<li>另一种解决方法是，使用<code>bind</code>方法，将<code>obj.y</code>这个方法绑定在<code>obj</code>上面。</li>
</ul>
</li>
<li><p><code>setInterval</code>指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行。<code>setInterval</code>的一个常见用途是实现轮询。</p>
</li>
<li><p>为了确保两次执行之间有固定的间隔，可以不用<code>setInterval</code>，而是每次执行结束后，使用<code>setTimeout</code>指定下一次执行的具体时间。</p>
</li>
<li><p><code>setTimeout</code>和<code>setInterval</code>函数，都返回一个整数值，表示计数器编号。将该整数传入<code>clearTimeout</code>和<code>clearInterval</code>函数，就可以取消对应的定时器。</p>
</li>
<li><p><code>setTimeout</code>和<code>setInterval</code>返回的整数值是连续的。</p>
</li>
<li><p> debounce（防抖动）的做法是，设置一个门槛值，表示两次 Ajax 通信的最小间隔时间。如果在间隔时间内，发生新的<code>keydown</code>事件，则不触发 Ajax 通信，并且重新开始计时。如果过了指定时间，没有发生新的<code>keydown</code>事件，再将数据发送出去。</p>
</li>
<li></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/16/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(16)/" data-id="ckutzsf3m00088sptdsy0eg2d" data-title="Javascript学习笔记(16)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Javascript%E7%AC%94%E8%AE%B0/" rel="tag">Javascript笔记</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Javascript学习笔记(15)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/10/15/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(15)/" class="article-date">
  <time class="dt-published" datetime="2021-10-15T12:27:58.000Z" itemprop="datePublished">2021-10-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/10/15/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(15)/">Javascript学习笔记(15)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ol>
<li>实例对象的<code>isPrototypeOf</code>方法，用来判断该对象是否为参数对象的原型。</li>
<li>实例对象的<code>__proto__</code>属性（前后各两个下划线），返回该对象的原型。该属性可读写。应该尽量少用这个属性，而是用<code>Object.getPrototypeOf()</code>和<code>Object.setPrototypeOf()</code>，进行原型对象的读写操作。</li>
<li>获取实例对象<code>obj</code>的原型对象，有三种方法。前两种不是很可靠。在改变原型对象时，一般要同时设置<code>constructor</code>属性。<ul>
<li><code>obj.__proto__</code></li>
<li><code>obj.constructor.prototype</code></li>
<li><code>Object.getPrototypeOf(obj)</code></li>
</ul>
</li>
<li><code>Object.getOwnPropertyNames</code>方法返回一个数组，成员是参数对象本身的所有属性的键名，不包含继承的属性键名。只获取那些可以遍历的属性，使用<code>Object.keys</code>方法。</li>
<li>对象实例的<code>hasOwnProperty</code>方法返回一个布尔值，用于判断某个属性定义在对象自身，还是定义在原型链上。</li>
<li><code>hasOwnProperty</code>方法是 JavaScript 之中唯一一个处理对象属性时，不会遍历原型链的方法。</li>
<li><code>in</code>运算符常用于检查一个属性是否存在。获得对象的所有可遍历属性（不管是自身的还是继承的），可以使用<code>for...in</code>循环。</li>
<li>如果要拷贝一个对象，需要做到下面两件事情。<ul>
<li>确保拷贝后的对象，与原对象具有同样的原型。</li>
<li>确保拷贝后的对象，与原对象具有同样的实例属性。</li>
</ul>
</li>
<li>进入严格模式的标志，是一行字符串<code>use strict</code>。严格模式可以用于整个脚本，也可以只用于单个函数。</li>
<li>严格模式使得 JavaScript 的语法变得更严格，更多的操作会显式报错。<ul>
<li>严格模式下，对只读属性赋值，或者删除不可配置（non-configurable）属性都会报错。</li>
<li>严格模式下，对一个只有取值器（getter）、没有存值器（setter）的属性赋值，会报错。</li>
<li>严格模式下，对禁止扩展的对象添加新属性，会报错。</li>
<li>严格模式下，使用<code>eval</code>或者<code>arguments</code>作为标识名，将会报错。下面的语句都会报错。</li>
<li>正常模式下，如果函数有多个重名的参数，可以用<code>arguments[i]</code>读取。严格模式下，这属于语法错误。</li>
<li>正常模式下，整数的第一位如果是<code>0</code>，表示这是八进制数，比如<code>0100</code>等于十进制的64。严格模式禁止这种表示法，整数第一位为<code>0</code>，将报错。</li>
<li>正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。</li>
<li>正常模式下，函数内部的<code>this</code>可能会指向全局对象，严格模式禁止这种用法，避免无意间创造全局变量。</li>
<li>严格模式下，函数直接调用时（不使用<code>new</code>调用），函数内部的<code>this</code>表示<code>undefined</code>（未定义），因此可以用<code>call</code>、<code>apply</code>和<code>bind</code>方法，将任意值绑定在<code>this</code>上面。正常模式下，<code>this</code>指向全局对象，如果绑定的值是非对象，将被自动转为对象再绑定上去，而<code>null</code>和<code>undefined</code>这两个无法转成对象的值，将被忽略。</li>
<li>函数内部不得使用<code>fn.caller</code>、<code>fn.arguments</code>，否则会报错。这意味着不能在函数内部得到调用栈了。</li>
<li>禁止使用 arguments.callee、arguments.caller 。</li>
<li>严格模式下无法删除变量，如果使用<code>delete</code>命令删除一个变量，会报错。只有对象的属性，且属性的描述对象的<code>configurable</code>属性设置为<code>true</code>，才能被<code>delete</code>命令删除。</li>
<li>严格模式下，使用<code>with</code>语句将报错。</li>
<li>正常模式下，JavaScript 语言有两种变量作用域（scope）：全局作用域和函数作用域。严格模式创设了第三种作用域：<code>eval</code>作用域。</li>
<li>严格模式下，函数内部改变参数与<code>arguments</code>的联系被切断了，两者不再存在联动关系。改变函数的参数，不会反应到<code>arguments</code>对象上来。</li>
<li>ES5 的严格模式只允许在全局作用域或函数作用域声明函数。</li>
<li>严格模式新增了一些保留字（implements、interface、let、package、private、protected、public、static、yield等）。使用这些词作为变量名将会报错。</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/15/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(15)/" data-id="ckutzsf3v000d8spt7vptflif" data-title="Javascript学习笔记(15)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Javascript%E7%AC%94%E8%AE%B0/" rel="tag">Javascript笔记</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Javascript学习笔记(14)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/10/14/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(14)/" class="article-date">
  <time class="dt-published" datetime="2021-10-14T15:58:03.000Z" itemprop="datePublished">2021-10-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/10/14/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(14)/">Javascript学习笔记(14)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ol>
<li><p>如果属性和方法定义在原型上，那么所有实例对象就能共享，不仅节省了内存，还体现了实例对象之间的联系。</p>
</li>
<li><p>JavaScript 规定，每个函数都有一个<code>prototype</code>属性，指向一个对象。所有对象都继承了<code>Object.prototype</code>的属性。这就是所有对象都有<code>valueOf</code>和<code>toString</code>方法的原因，因为这是从<code>Object.prototype</code>继承的。</p>
</li>
<li><p><code>Object.prototype</code>的原型是<code>null</code>。<code>null</code>没有任何属性和方法，也没有自己的原型。<code>prototype</code>对象有一个<code>constructor</code>属性，默认指向<code>prototype</code>对象所在的构造函数。</p>
</li>
<li><p><code>constructor</code>属性的作用是，可以得知某个实例对象，到底是哪一个构造函数产生的。另一方面，有了<code>constructor</code>属性，就可以从一个实例对象新建另一个实例。</p>
</li>
<li><p><code>constructor</code>属性表示原型对象与构造函数之间的关联关系，如果修改了原型对象，一般会同时修改<code>constructor</code>属性，防止引用的时候出错。</p>
</li>
<li><p>要么将<code>constructor</code>属性重新指向原来的构造函数，要么只在原型对象上添加方法，这样可以保证<code>instanceof</code>运算符不会失真。</p>
</li>
<li><p>通过<code>name</code>属性，可以从实例得到构造函数的名称。</p>
</li>
<li><p><code>instanceof</code>运算符返回一个布尔值，表示对象是否为某个构造函数的实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v <span class="keyword">instanceof</span> Vehicle</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">Vehicle.prototype.isPrototypeOf(v)</span><br></pre></td></tr></table></figure></li>
<li><p>由于任意对象（除了<code>null</code>）都是<code>Object</code>的实例，所以<code>instanceof</code>运算符可以判断一个值是否为非<code>null</code>的对象。</p>
</li>
<li><p><code>instanceof</code>的原理是检查右边构造函数的<code>prototype</code>属性，是否在左边对象的原型链上。有一种特殊情况，就是左边对象的原型链上，只有<code>null</code>对象。这时，<code>instanceof</code>判断会失真。</p>
</li>
<li><p><code>instanceof</code>运算符的一个用处，是判断值的类型。注意，<code>instanceof</code>运算符只能用于对象，不适用原始类型的值。</p>
</li>
<li><p>对于<code>undefined</code>和<code>null</code>，<code>instanceof</code>运算符总是返回<code>false</code>。</p>
</li>
<li><p>让一个构造函数继承另一个构造函数可以分成两步实现。第一步是在子类的构造函数中，调用父类的构造函数。第二步，是让子类的原型指向父类的原型，这样子类就可以继承父类原型</p>
</li>
<li><p>模块是实现特定功能的一组属性和方法的封装。使用“立即执行函数”（Immediately-Invoked Function Expression，IIFE），将相关的属性和方法封装在一个函数作用域里面，可以达到不暴露私有成员的目的。</p>
</li>
<li><p>如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用“放大模式”（augmentation）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span> (<span class="params">mod</span>)</span>&#123;</span><br><span class="line">　mod.m3 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">　　<span class="comment">//...</span></span><br><span class="line">　&#125;;</span><br><span class="line">　<span class="keyword">return</span> mod;</span><br><span class="line">&#125;)(module1);</span><br></pre></td></tr></table></figure></li>
<li><p>第一个执行的部分有可能加载一个不存在空对象，这时就要采用”宽放大模式”（Loose augmentation）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span> (<span class="params">mod</span>) </span>&#123;</span><br><span class="line">　<span class="comment">//...</span></span><br><span class="line">　<span class="keyword">return</span> mod;</span><br><span class="line">&#125;)(<span class="built_in">window</span>.module1 || &#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>与”放大模式”相比，“宽放大模式”就是“立即执行函数”的参数可以是空对象。</p>
</li>
<li><p>独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。立即执行函数还可以起到命名空间的作用。</p>
</li>
<li><p><code>Object.getPrototypeOf</code>方法返回参数对象的原型。这是获取原型对象的标准方法。</p>
<ul>
<li> 空对象的原型是 Object.prototype。</li>
<li>Object.prototype 的原型是 null。</li>
<li>函数的原型是 Function.prototype。</li>
</ul>
</li>
<li><p><code>Object.setPrototypeOf</code>方法为参数对象设置原型，返回该参数对象。它接受两个参数，第一个是现有对象，第二个是原型对象。</p>
</li>
<li><p>JavaScript 提供了<code>Object.create()</code>方法，用来满足这种需求。该方法接受一个对象作为参数，然后以它为原型，返回一个实例对象。该实例完全继承原型对象的属性。</p>
</li>
<li><p>下面三种方式生成的新对象是等价的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = <span class="built_in">Object</span>.create(&#123;&#125;);</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype);</span><br><span class="line"><span class="keyword">var</span> obj3 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure></li>
<li><p>如果想要生成一个不继承任何属性（比如没有<code>toString()</code>和<code>valueOf()</code>方法）的对象，可以将<code>Object.create()</code>的参数设为<code>null</code>。</p>
</li>
<li><p>使用<code>Object.create()</code>方法的时候，必须提供对象原型，即参数不能为空，或者不是对象，否则会报错。</p>
</li>
<li><p><code>Object.create()</code>方法生成的新对象，动态继承了原型。在原型上添加或修改任何方法，会立刻反映在新对象之上。</p>
</li>
<li><p>除了对象的原型，<code>Object.create()</code>方法还可以接受第二个参数。该参数是一个属性描述对象，它所描述的对象属性，会添加到实例对象，作为该对象自身的属性。</p>
</li>
<li><p><code>Object.create()</code>方法生成的对象，继承了它的原型对象的构造函数。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/14/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(14)/" data-id="ckutzsf3o000a8spt98dvengz" data-title="Javascript学习笔记(14)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Javascript%E7%AC%94%E8%AE%B0/" rel="tag">Javascript笔记</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Javascript学习笔记(13)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/10/14/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(13)/" class="article-date">
  <time class="dt-published" datetime="2021-10-14T09:03:35.000Z" itemprop="datePublished">2021-10-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/10/14/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(13)/">Javascript学习笔记(13)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ol>
<li><p>JSON 对值的类型和格式有严格的规定:</p>
<ul>
<li><p>复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象。</p>
</li>
<li><p>原始类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和<code>null</code>（不能使用<code>NaN</code>, <code>Infinity</code>, <code>-Infinity</code>和<code>undefined</code>）。</p>
</li>
<li><p>字符串必须使用双引号表示，不能使用单引号。</p>
</li>
<li><p>对象的键名必须放在双引号里面。</p>
</li>
<li><p>数组或对象最后一个成员的后面，不能加逗号。</p>
</li>
</ul>
</li>
<li><p><code>JSON.stringify()</code>方法用于将一个值转为 JSON 字符串。该字符串符合 JSON 格式，并且可以被<code>JSON.parse()</code>方法还原。</p>
</li>
<li><p>如果对象的属性是<code>undefined</code>、函数或 XML 对象，该属性会被<code>JSON.stringify()</code>过滤。如果数组的成员是<code>undefined</code>、函数或 XML 对象，则这些值被转成<code>null</code>。正则对象会被转成空对象。</p>
</li>
<li><p><code>JSON.stringify()</code>方法会忽略对象的不可遍历的属性。</p>
</li>
<li><p><code>JSON.stringify()</code>方法还可以接受一个数组，作为第二个参数，指定参数对象的哪些属性需要转成字符串。这个类似白名单的数组，只对对象的属性有效，对数组无效。</p>
</li>
<li><p>第二个参数还可以是一个函数，用来更改<code>JSON.stringify()</code>的返回值。如果处理函数返回<code>undefined</code>或没有返回值，则该属性会被忽略。</p>
</li>
<li><p><code>JSON.stringify()</code>还可以接受第三个参数，用于增加返回的 JSON 字符串的可读性。第三个属性如果是一个数字，则表示每个属性前面添加的空格（最多不超过10个）。</p>
</li>
<li><p>如果参数对象有自定义的<code>toJSON()</code>方法，那么<code>JSON.stringify()</code>会使用这个方法的返回值作为参数，而忽略原对象的其他属性。<code>toJSON()</code>方法的一个应用是，将正则对象自动转为字符串。</p>
</li>
<li><p><code>JSON.parse()</code>方法用于将 JSON 字符串转换成对应的值。<code>JSON.parse()</code>方法可以接受一个处理函数，作为第二个参数，用法与<code>JSON.stringify()</code>方法类似。</p>
</li>
<li><p>对象是什么：</p>
<ul>
<li>对象是单个实物的抽象。</li>
<li>对象是一个容器，封装了属性（property）和方法（method）。</li>
</ul>
</li>
<li><p>JavaScript 语言使用构造函数（constructor）作为对象的模板。所谓”构造函数”，就是专门用来生成实例对象的函数。它就是对象的模板，描述实例对象的基本结构。</p>
</li>
<li><p>构造函数的特点有两个。</p>
<ul>
<li>函数体内部使用了<code>this</code>关键字，代表了所要生成的对象实例。</li>
<li>生成对象的时候，必须使用<code>new</code>命令。</li>
</ul>
</li>
<li><p>为了保证构造函数必须与<code>new</code>命令一起使用，一个解决办法是，构造函数内部使用严格模式，即第一行加上<code>use strict</code>。JavaScript 不允许对<code>undefined</code>添加属性。</p>
</li>
<li><p>使用<code>new</code>命令时，它后面的函数依次执行下面的步骤。</p>
<ul>
<li><p>创建一个空对象，作为将要返回的对象实例。</p>
</li>
<li><p>将这个空对象的原型，指向构造函数的<code>prototype</code>属性。</p>
</li>
<li><p>将这个空对象赋值给函数内部的<code>this</code>关键字。</p>
</li>
<li><p>开始执行构造函数内部的代码。</p>
</li>
</ul>
</li>
<li><p>如果构造函数内部有<code>return</code>语句，而且<code>return</code>后面跟着一个对象，<code>new</code>命令会返回<code>return</code>语句指定的对象；否则，就会不管<code>return</code>语句，返回<code>this</code>对象。</p>
</li>
<li><p>函数内部可以使用<code>new.target</code>属性。如果当前函数是<code>new</code>命令调用，<code>new.target</code>指向当前函数，否则为<code>undefined</code>。</p>
</li>
<li><p>使用<code>Object.create()</code>方法以这个现有的对象作为模板，生成新的实例对象。</p>
</li>
<li><p>简单说，<code>this</code>就是属性或方法“当前”所在的对象。总结一下，JavaScript 语言之中，一切皆对象，运行环境也是对象，所以函数都是在某个对象之中运行，<code>this</code>就是函数运行时所在的对象（环境）。</p>
</li>
<li><p><code>this</code>主要有以下几个使用场合。</p>
<ul>
<li>全局环境使用<code>this</code>，它指的就是顶层对象<code>window</code>。</li>
<li>构造函数中的<code>this</code>，指的是实例对象。</li>
<li>如果对象的方法里面包含<code>this</code>，<code>this</code>的指向就是方法运行时所在的对象。该方法赋值给另一个对象，就会改变<code>this</code>的指向。</li>
</ul>
</li>
<li><p>如果<code>this</code>所在的方法不在对象的第一层，这时<code>this</code>只是指向当前一层的对象，而不会继承更上面的层。</p>
</li>
<li><p>使用<code>this</code>注意点：</p>
<ul>
<li><p>由于<code>this</code>的指向是不确定的，所以切勿在函数中包含多层的<code>this</code>。</p>
<ul>
<li>事实上，使用一个变量固定<code>this</code>的值，然后内层函数调用这个变量，是非常常见的做法，请务必掌握。</li>
<li>JavaScript 提供了严格模式，也可以硬性避免这种问题。严格模式下，如果函数内部的<code>this</code>指向顶层对象，就会报错。</li>
</ul>
</li>
<li><p>数组的<code>map</code>和<code>foreach</code>方法，允许提供一个函数作为参数。这个函数内部不应该使用<code>this</code>。</p>
<ul>
<li><p>一种方法，就是前面提到的，使用中间变量固定<code>this</code>。</p>
</li>
<li><p>另一种方法是将<code>this</code>当作<code>foreach</code>方法的第二个参数，固定它的运行环境。</p>
</li>
</ul>
</li>
<li><p>回调函数中的<code>this</code>往往会改变指向，最好避免使用。</p>
</li>
</ul>
</li>
<li><p>JavaScript 提供了<code>call</code>、<code>apply</code>、<code>bind</code>这三个方法，来切换/固定<code>this</code>的指向。</p>
<ul>
<li>Function.prototype.call()：函数实例的<code>call</code>方法，可以指定函数内部<code>this</code>的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。<ul>
<li><code>call</code>方法的参数，应该是一个对象。如果参数为空、<code>null</code>和<code>undefined</code>，则默认传入全局对象。</li>
<li><code>call</code>方法的一个应用是调用对象的原生方法。</li>
</ul>
</li>
<li><code>apply</code>方法的作用与<code>call</code>方法类似，也是改变<code>this</code>指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数。<ul>
<li>通过<code>apply</code>方法，利用<code>Array</code>构造函数将数组的空元素变成<code>undefined</code>。</li>
<li>利用数组对象的<code>slice</code>方法，可以将一个类似数组的对象（比如<code>arguments</code>对象）转为真正的数组。这个方法起作用的前提是，被处理的对象必须有<code>length</code>属性，以及相对应的数字键。</li>
<li>绑定回调函数的对象。</li>
</ul>
</li>
<li><code>bind()</code>方法用于将函数体内的<code>this</code>绑定到某个对象，然后返回一个新函数。<ul>
<li>如果<code>bind()</code>方法的第一个参数是<code>null</code>或<code>undefined</code>，等于将<code>this</code>绑定到全局对象，函数运行时<code>this</code>指向顶层对象（浏览器为<code>window</code>）。</li>
<li><code>bind()</code>方法每运行一次，就返回一个新函数。</li>
<li>回调函数是 JavaScript 最常用的模式之一，但是一个常见的错误是，将包含<code>this</code>的方法直接当作回调函数。</li>
<li>还有一种情况比较隐蔽，就是某些数组方法可以接受一个函数当作参数。例如<code>forEach()</code>方法回调函数指向全局对象。</li>
<li>自我理解：相当于还是bind前面这个方法，但对象固定成括号里的了。常常体悟这一节。</li>
</ul>
</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/14/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(13)/" data-id="ckutzsf3400048spt1zwx43sl" data-title="Javascript学习笔记(13)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Javascript%E7%AC%94%E8%AE%B0/" rel="tag">Javascript笔记</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Javascript学习笔记(12)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/10/14/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(12)/" class="article-date">
  <time class="dt-published" datetime="2021-10-14T06:38:42.000Z" itemprop="datePublished">2021-10-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/10/14/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(12)/">Javascript学习笔记(12)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ol>
<li>如果在正则表达式之中，某个字符只表示它字面的含义，那么它们就叫做“字面量字符”（literal characters）。</li>
<li>除了字面量字符以外，还有一部分字符有特殊含义，不代表字面的意思。它们叫做“元字符”（metacharacters）：<ul>
<li>点字符（<code>.</code>）匹配除回车（<code>\r</code>）、换行(<code>\n</code>) 、行分隔符（<code>\u2028</code>）和段分隔符（<code>\u2029</code>）以外的所有字符。注意，对于码点大于<code>0xFFFF</code>字符，点字符不能正确匹配，会认为这是两个字符。</li>
<li>位置字符用来提示字符所处的位置，主要有两个字符。使用/^test$/表示从开始位置到结束位置只有test。<ul>
<li><code>^</code> 表示字符串的开始位置</li>
<li><code>$</code> 表示字符串的结束位置</li>
</ul>
</li>
<li>竖线符号（<code>|</code>）在正则表达式中表示“或关系”（OR）。</li>
</ul>
</li>
<li>正则表达式中那些有特殊含义的元字符，如果要匹配它们本身，就需要在它们前面要加上反斜杠。正则表达式中，需要反斜杠转义的，一共有12个字符：<code>^</code>、<code>.</code>、<code>[</code>、<code>$</code>、<code>(</code>、<code>)</code>、<code>|</code>、<code>*</code>、<code>+</code>、<code>?</code>、<code>&#123;</code>和<code>\</code>。</li>
<li>需要特别注意的是，如果使用<code>RegExp</code>方法生成正则对象，转义需要使用两个斜杠，因为字符串内部会先转义一次。</li>
<li>字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内。</li>
<li>如果方括号内的第一个字符是<code>[^]</code>，则表示除了字符类之中的字符，其他字符都可以匹配。如果方括号内没有其他字符，即只有<code>[^]</code>，就表示匹配一切字符，其中包括换行符。</li>
<li>某些情况下，对于连续序列的字符，连字符（<code>-</code>）用来提供简写形式，表示字符的连续范围。</li>
<li>预定义模式指的是某些常见模式的简写方式。<code>[\S\s]</code>指代一切字符。<ul>
<li><code>\d</code> 匹配0-9之间的任一数字，相当于<code>[0-9]</code>。</li>
<li><code>\D</code> 匹配所有0-9以外的字符，相当于<code>[^0-9]</code>。</li>
<li><code>\w</code> 匹配任意的字母、数字和下划线，相当于<code>[A-Za-z0-9_]</code>。</li>
<li><code>\W</code> 除所有字母、数字和下划线以外的字符，相当于<code>[^A-Za-z0-9_]</code>。</li>
<li><code>\s</code> 匹配空格（包括换行符、制表符、空格符等），相等于<code>[ \t\r\n\v\f]</code>。</li>
<li><code>\S</code> 匹配非空格的字符，相当于<code>[^ \t\r\n\v\f]</code>。</li>
<li><code>\b</code> 匹配词的边界。</li>
<li><code>\B</code> 匹配非词边界，即在词的内部。</li>
</ul>
</li>
<li>模式的精确匹配次数，使用大括号<code>&#123;&#125;</code>表示。<code>&#123;n&#125;</code>表示恰好重复<code>n</code>次，<code>&#123;n,&#125;</code>表示至少重复<code>n</code>次，<code>&#123;n,m&#125;</code>表示重复不少于<code>n</code>次，不多于<code>m</code>次。</li>
<li>量词符用来设定某个模式出现的次数。默认情况下都是最大可能匹配，即匹配到下一个字符不满足匹配规则为止。如果想将贪婪模式改为非贪婪模式，可以在量词符后面加一个问号。<ul>
<li><code>?</code> 问号表示某个模式出现0次或1次，等同于<code>&#123;0, 1&#125;</code>。</li>
<li><code>*</code> 星号表示某个模式出现0次或多次，等同于<code>&#123;0,&#125;</code>。</li>
<li><code>+</code> 加号表示某个模式出现1次或多次，等同于<code>&#123;1,&#125;</code>。</li>
</ul>
</li>
<li><code>g</code>修饰符表示全局匹配（global）。默认情况下，正则对象区分字母的大小写，加上<code>i</code>修饰符以后表示忽略大小写（ignoreCase）。</li>
<li><code>m</code>修饰符表示多行模式（multiline），加上<code>m</code>修饰符以后，<code>^</code>和<code>$</code>还会匹配行首和行尾，即<code>^</code>和<code>$</code>会识别换行符（<code>\n</code>）。</li>
<li>正则表达式的括号表示分组匹配，括号中的模式可以用来匹配分组的内容。注意，使用组匹配时，不宜同时使用<code>g</code>修饰符，否则<code>match</code>方法不会捕获分组的内容。</li>
<li>正则表达式内部，还可以用<code>\n</code>引用括号匹配的内容，<code>n</code>是从1开始的自然数，表示对应顺序的括号。</li>
<li><code>(?:x)</code>称为非捕获组（Non-capturing group），表示不返回该组匹配的内容，即匹配的结果中不计入这个括号。</li>
<li><code>x(?=y)</code>称为先行断言（Positive look-ahead），<code>x</code>只有在<code>y</code>前面才匹配，<code>y</code>不会被计入返回结果。比如，要匹配后面跟着百分号的数字，可以写成<code>/\d+(?=%)/</code>。</li>
<li><code>x(?!y)</code>称为先行否定断言（Negative look-ahead），<code>x</code>只有不在<code>y</code>前面才匹配，<code>y</code>不会被计入返回结果。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/14/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(12)/" data-id="ckutzsf3900058spt29e7655i" data-title="Javascript学习笔记(12)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Javascript%E7%AC%94%E8%AE%B0/" rel="tag">Javascript笔记</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Javascript学习笔记(11)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/10/13/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(11)/" class="article-date">
  <time class="dt-published" datetime="2021-10-13T14:04:52.000Z" itemprop="datePublished">2021-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/10/13/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(11)/">Javascript学习笔记(10)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ol>
<li><p>如果参数为空, <code>Math.min</code>返回<code>Infinity</code>, <code>Math.max</code>返回<code>-Infinity</code>。</p>
</li>
<li><p><code>Math.floor</code>方法和<code>Math.ceil</code>方法结合起来，可以实现一个总是返回数值的整数部分的函数。</p>
</li>
<li><p>注意<code>Math.round</code>方法对负数的处理（主要是对<code>0.5</code>的处理）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.round(-<span class="number">1.1</span>) <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">Math</span>.round(-<span class="number">1.5</span>) <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">Math</span>.round(-<span class="number">1.6</span>) <span class="comment">// -2</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>Math.pow</code>方法返回以第一个参数为底数、第二个参数为指数的幂运算值。<code>Math.sqrt</code>方法返回参数值的平方根。如果参数是一个负值，则返回<code>NaN</code>。</p>
</li>
<li><p>如果要计算以10为底的对数，可以先用<code>Math.log</code>求出自然对数，然后除以<code>Math.LN10</code>；求以2为底的对数，可以除以<code>Math.LN2</code>。</p>
</li>
<li><p>无论有没有参数，直接调用<code>Date</code>总是返回当前时间。</p>
</li>
<li><p><code>Date</code>实例有一个独特的地方。其他对象求值的时候，都是默认调用<code>.valueOf()</code>方法，但是<code>Date</code>实例求值的时候，默认调用的是<code>toString()</code>方法。</p>
</li>
<li><p>关于<code>Date</code>构造函数的参数，有几点说明。</p>
<ul>
<li>第一点，参数可以是负整数，代表1970年元旦之前的时间。</li>
<li>第二点，只要是能被<code>Date.parse()</code>方法解析的字符串，都可以当作参数。</li>
<li>第三，参数为年、月、日等多个整数时，年和月是不能省略的，其他参数都可以省略的。</li>
</ul>
</li>
<li><p>注意，月份从<code>0</code>开始计算，但是，天数从<code>1</code>开始计算。另外，除了日期的默认值为<code>1</code>，小时、分钟、秒钟和毫秒的默认值都是<code>0</code>。</p>
</li>
<li><p>两个日期实例对象进行减法运算时，返回的是它们间隔的毫秒数；进行加法运算时，返回的是两个字符串连接而成的新字符串。</p>
</li>
<li><p><code>Date.now</code>方法返回当前时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数。</p>
</li>
<li><p><code>Date.parse</code>方法用来解析日期字符串，返回该时间距离时间零点（1970年1月1日 00:00:00）的毫秒数。如果解析失败，返回<code>NaN</code>。</p>
</li>
<li><p>区别在于<code>Date.UTC</code>方法的参数，会被解释为 UTC 时间（世界标准时间），<code>Date</code>构造函数的参数会被解释为当前时区的时间。</p>
</li>
<li><p>计算本年度还剩多少天：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">leftDays</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> today = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="keyword">var</span> endYear = <span class="keyword">new</span> <span class="built_in">Date</span>(today.getFullYear(), <span class="number">11</span>, <span class="number">31</span>, <span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999</span>);</span><br><span class="line">  <span class="keyword">var</span> msPerDay = <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.round((endYear.getTime() - today.getTime()) / msPerDay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>新建正则表达式有两种方法。一种是使用字面量，以斜杠表示开始和结束。另一种是使用<code>RegExp</code>构造函数。实际应用中，基本上都采用字面量定义正则表达式。</p>
</li>
<li><p>一类是修饰符相关，用于了解设置了什么修饰符。</p>
<ul>
<li><code>RegExp.prototype.ignoreCase</code>：返回一个布尔值，表示是否设置了<code>i</code>修饰符。</li>
<li><code>RegExp.prototype.global</code>：返回一个布尔值，表示是否设置了<code>g</code>修饰符。</li>
<li><code>RegExp.prototype.multiline</code>：返回一个布尔值，表示是否设置了<code>m</code>修饰符。</li>
<li><code>RegExp.prototype.flags</code>：返回一个字符串，包含了已经设置的所有修饰符，按字母排序。</li>
</ul>
</li>
<li><p>正则实例对象的<code>test</code>方法返回一个布尔值，表示当前模式是否能匹配参数字符串。如果正则表达式带有<code>g</code>修饰符，则每一次<code>test</code>方法都从上一次结束的位置开始向后匹配。</p>
</li>
<li><p>带有<code>g</code>修饰符时，可以通过正则对象的<code>lastIndex</code>属性指定开始搜索的位置。注意，带有<code>g</code>修饰符时，正则表达式内部会记住上一次的<code>lastIndex</code>属性，这时不应该更换所要匹配的字符串，否则会有一些难以察觉的错误。</p>
</li>
<li><p><code>lastIndex</code>属性只对同一个正则表达式有效。</p>
</li>
<li><p>正则实例对象的<code>exec()</code>方法，用来返回匹配结果。如果发现匹配，就返回一个数组，成员是匹配成功的子字符串，否则返回<code>null</code>。</p>
</li>
<li><p>如果正则表示式包含圆括号（即含有“组匹配”），则返回的数组会包括多个成员。第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。</p>
</li>
<li><p>字符串的实例方法之中，有4种与正则表达式有关。</p>
<ul>
<li><code>String.prototype.match()</code>：返回一个数组，成员是所有匹配的子字符串。</li>
<li><code>String.prototype.search()</code>：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。</li>
<li><code>String.prototype.replace()</code>：按照给定的正则表达式进行替换，返回替换后的字符串。</li>
<li><code>String.prototype.split()</code>：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员。</li>
</ul>
</li>
<li><p><code>String.prototype.match()</code>如果正则表达式带有<code>g</code>修饰符，则该方法与正则对象的<code>exec</code>方法行为不同，会一次性返回所有匹配成功的结果。</p>
</li>
<li><p><code>replace</code>方法的第二个参数可以使用美元符号<code>$</code>，用来指代所替换的内容。<code>replace</code>方法的第二个参数还可以是一个函数，将每一个匹配内容替换为函数返回值。</p>
</li>
<li><p>如果正则表达式带有括号，则<code>String.prototype.split()</code>括号匹配的部分也会作为数组成员返回。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/13/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(11)/" data-id="ckutzsf3100038spt1h4ka1z8" data-title="Javascript学习笔记(10)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Javascript%E7%AC%94%E8%AE%B0/" rel="tag">Javascript笔记</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Javascript学习笔记(10)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/10/13/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(10)/" class="article-date">
  <time class="dt-published" datetime="2021-10-12T17:11:50.000Z" itemprop="datePublished">2021-10-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/10/13/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(10)/">Javascript学习笔记(9)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ol>
<li>所谓“包装对象”，指的是与数值、字符串、布尔值分别相对应的<code>Number</code>、<code>String</code>、<code>Boolean</code>三个原生对象。这三个原生对象可以把原始类型的值变成（包装成）对象。</li>
<li>包装对象的设计目的，首先是使得“对象”这种类型可以覆盖 JavaScript 所有的值，整门语言有一个通用的数据模型，其次是使得原始类型的值也有办法调用自己的方法。</li>
<li>这三个对象作为构造函数使用（带有<code>new</code>）时，可以将原始类型的值转为对象；作为普通函数使用时（不带有<code>new</code>），可以将任意类型的值，转为原始类型的值。</li>
<li>某些场合，原始类型的值会自动当作包装对象调用，即调用包装对象的属性和方法。这时，JavaScript 引擎会自动将原始类型的值转为包装对象实例，并在使用后立刻销毁实例。</li>
<li>自动转换生成的包装对象是只读的，无法修改。所以，字符串无法添加新属性。如果要为字符串添加属性，只有在它的原型对象<code>String.prototype</code>上定义。</li>
<li>注意，<code>false</code>对应的包装对象实例，布尔运算结果也是<code>true</code>。</li>
<li><code>Number</code>对象拥有以下一些静态属性（即直接定义在<code>Number</code>对象上的属性，而不是定义在实例上的属性）。<ul>
<li><code>Number.POSITIVE_INFINITY</code>：正的无限，指向<code>Infinity</code>。</li>
<li><code>Number.NEGATIVE_INFINITY</code>：负的无限，指向<code>-Infinity</code>。</li>
<li><code>Number.NaN</code>：表示非数值，指向<code>NaN</code>。</li>
<li><code>Number.MIN_VALUE</code>：表示最小的正数（即最接近0的正数，在64位浮点数体系中为<code>5e-324</code>），相应的，最接近0的负数为<code>-Number.MIN_VALUE</code>。</li>
<li><code>Number.MAX_SAFE_INTEGER</code>：表示能够精确表示的最大整数，即<code>9007199254740991</code>。</li>
<li><code>Number.MIN_SAFE_INTEGER</code>：表示能够精确表示的最小整数，即<code>-9007199254740991</code>。</li>
</ul>
</li>
<li><code>toString</code>方法可以接受一个参数，表示输出的进制。<code>toString</code>方法只能将十进制的数，转为其他进制的字符串。如果要将其他进制的数，转回十进制，需要使用<code>parseInt</code>方法。</li>
<li><code>toFixed()</code>方法先将一个数转为指定位数的小数，然后返回这个小数对应的字符串。由于浮点数的原因，小数<code>5</code>的四舍五入是不确定的，使用的时候必须小心。</li>
<li><code>toExponential</code>方法用于将一个数转为科学计数法形式。<code>toExponential</code>方法的参数是小数点后有效数字的位数，范围为0到100，超出这个范围，会抛出一个 RangeError 错误。</li>
<li><code>Number.prototype.toPrecision()</code>方法用于将一个数转为指定位数的有效数字。</li>
<li><code>Number.prototype.toLocaleString()</code>方法接受一个地区码作为参数，返回一个字符串，表示当前数字在该地区的当地书写形式。</li>
<li>注意，数值的自定义方法，只能定义在它的原型对象<code>Number.prototype</code>上面，数值本身是无法自定义属性的。</li>
<li><code>String.fromCharCode()</code>方法的参数是一个或多个数值，代表 Unicode 码点，返回值是这些码点组成的字符串。该方法不支持 Unicode 码点大于<code>0xFFFF</code>的字符。</li>
<li><code>charCodeAt()</code>方法返回字符串指定位置的 Unicode 码点（十进制表示），相当于<code>String.fromCharCode()</code>的逆操作。如果没有任何参数，<code>charCodeAt</code>返回首字符的 Unicode 码点，如果参数为负数，或大于等于字符串的长度，<code>charCodeAt</code>返回<code>NaN</code>。</li>
<li><code>concat</code>方法用于连接两个字符串，返回一个新字符串，不改变原字符串，该方法可以接受多个参数。</li>
<li><code>slice()</code>方法用于从原字符串取出子字符串并返回，不改变原字符串。</li>
<li><code>substring</code>方法用于从原字符串取出子字符串并返回，不改变原字符串，跟<code>slice</code>方法很相像。如果第一个参数大于第二个参数，<code>substring</code>方法会自动更换两个参数的位置。如果参数是负数，<code>substring</code>方法会自动将负数转为0。</li>
<li>由于这些规则违反直觉，因此不建议使用<code>substring</code>方法，应该优先使用<code>slice</code>。</li>
<li><code>substr</code>方法的第一个参数是子字符串的开始位置（从0开始计算），第二个参数是子字符串的长度。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。</li>
<li><code>indexOf</code>方法还可以接受第二个参数，表示从该位置开始向后匹配。另外，<code>lastIndexOf</code>的第二个参数表示从该位置起向前匹配。</li>
<li><code>trim</code>方法用于去除字符串两端的空格，返回一个新字符串，不改变原字符串。该方法去除的不仅是空格，还包括制表符（<code>\t</code>、<code>\v</code>）、换行符（<code>\n</code>）和回车符（<code>\r</code>）。</li>
<li><code>toLowerCase</code>方法和<code>toUpperCase</code>方法都返回一个新字符串，不改变原字符串。</li>
<li><code>match</code>方法用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回<code>null</code>。返回的数组还有<code>index</code>属性和<code>input</code>属性，分别表示匹配字符串开始的位置和原始字符串。<code>match</code>方法还可以使用正则表达式作为参数。</li>
<li><code>replace</code>方法用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有<code>g</code>修饰符的正则表达式）。</li>
<li><code>search</code>方法的用法基本等同于<code>match</code>，但是返回值为匹配的第一个位置。如果没有找到匹配，则返回<code>-1</code>。</li>
<li><code>split</code>方法还可以接受第二个参数，限定返回数组的最大成员数。<code>split</code>方法还可以使用正则表达式作为参数。</li>
<li><code>localeCompare</code>方法会考虑自然语言的排序情况。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。</li>
<li><code>localeCompare</code>还可以有第二个参数，指定所使用的语言（默认是英语），然后根据该语言的规则进行比较。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/13/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(10)/" data-id="ckutzsf1w00008spt3hslazcf" data-title="Javascript学习笔记(9)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Javascript%E7%AC%94%E8%AE%B0/" rel="tag">Javascript笔记</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Javascript学习笔记(9)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/10/12/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(9)/" class="article-date">
  <time class="dt-published" datetime="2021-10-12T12:50:43.000Z" itemprop="datePublished">2021-10-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/10/12/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(9)/">Javascript学习笔记(9)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ol>
<li><p><code>Array</code>是 JavaScript 的原生对象，同时也是一个构造函数，可以用它生成新的数组。</p>
</li>
<li><p><code>Array.isArray</code>方法返回一个布尔值，表示参数是否为数组。它可以弥补<code>typeof</code>运算符的不足。</p>
</li>
<li><p>数组的<code>valueOf</code>方法返回数组本身，数组的<code>toString</code>方法返回数组的字符串形式。</p>
</li>
<li><p><code>shift()</code>的前提是数组元素不能是<code>0</code>或任何布尔值等于<code>false</code>的元素。</p>
</li>
<li><p><code>concat</code>方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变。</p>
</li>
<li><p>如果数组成员包括对象，<code>concat</code>方法返回当前数组的一个浅拷贝。所谓“浅拷贝”，指的是新数组拷贝的是对象的引用。</p>
</li>
<li><p><code>reverse</code>方法将改变原数组。如果<code>slice()</code>方法的参数是负数，则表示倒数计算的位置。<code>slice()</code>方法的一个重要应用，是将类似数组的对象转为真正的数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.slice.call(&#123; <span class="number">0</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">1</span>: <span class="string">&#x27;b&#x27;</span>, <span class="attr">length</span>: <span class="number">2</span> &#125;)</span><br><span class="line"><span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;div&quot;</span>));</span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br></pre></td></tr></table></figure></li>
<li><p><code>splice()</code>方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。如果只提供第一个参数，等同于将原数组在指定位置拆分成两个数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.splice(start, count, addElement1, addElement2, ...);</span><br></pre></td></tr></table></figure></li>
<li><p><code>sort</code>的参数函数本身接受两个参数，表示进行比较的两个数组成员。如果该函数的返回值大于<code>0</code>，表示第一个成员排在第二个成员后面；其他情况下，都是第一个元素排在第二个元素前面。</p>
</li>
<li><p><code>map()</code>方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。</p>
</li>
<li><p><code>map()</code>方法接受一个函数作为参数。该函数调用时，<code>map()</code>方法向它传入三个参数：当前成员、当前位置和数组本身。</p>
</li>
<li><p><code>map()</code>方法还可以接受第二个参数，用来绑定回调函数内部的<code>this</code>变量。<code>map()</code>方法不会跳过<code>undefined</code>和<code>null</code>，但是会跳过空位。</p>
</li>
<li><p>如果数组遍历的目的是为了得到返回值，那么使用<code>map()</code>方法，否则使用<code>forEach()</code>方法。<code>forEach()</code>方法和<code>map()</code>方法的使用类似。</p>
</li>
<li><p>注意，<code>forEach()</code>方法无法中断执行，总是会将所有成员遍历完。如果希望符合某种条件时，就中断遍历，要使用<code>for</code>循环。</p>
</li>
<li><p><code>filter()</code>方法用于过滤数组成员，满足条件的成员组成一个新数组返回。它的参数是一个函数，所有数组成员依次执行该函数，返回结果为<code>true</code>的成员组成一个新数组返回。该方法不会改变原数组。</p>
</li>
<li><p><code>some</code>方法检验其中是否有满足条件的，<code>every</code>方法检验是否每个都满足条件。注意，对于空数组，<code>some</code>方法返回<code>false</code>，<code>every</code>方法返回<code>true</code>，回调函数都不会执行。</p>
</li>
<li><p><code>reduce()</code>方法和<code>reduceRight()</code>方法依次处理数组的每个成员，最终累计为一个值。它们的差别是，<code>reduce()</code>是从左到右处理（从第一个成员到最后一个成员），<code>reduceRight()</code>则是从右到左（从最后一个成员到第一个成员），其他完全一样。</p>
</li>
<li><p>建议总是加上第二个参数，这样比较符合直觉，每个数组成员都会依次执行<code>reduce()</code>方法的参数函数。另外，第二个参数可以防止空数组报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].reduce(<span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  a,   <span class="comment">// 累积变量，必须</span></span></span></span><br><span class="line"><span class="params"><span class="function">  b,   <span class="comment">// 当前变量，必须</span></span></span></span><br><span class="line"><span class="params"><span class="function">  i,   <span class="comment">// 当前位置，可选</span></span></span></span><br><span class="line"><span class="params"><span class="function">  arr  <span class="comment">// 原数组，可选</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... ...</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>indexOf</code>方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回<code>-1</code>，还可以接受第二个参数，表示搜索的开始位置。<code>lastIndexOf</code>方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回<code>-1</code>。</p>
</li>
<li><p>注意，这两个方法不能用来搜索<code>NaN</code>的位置，即它们无法确定数组成员是否包含<code>NaN</code>。因为这两个方法内部，使用严格相等运算符（<code>===</code>）进行比较，而<code>NaN</code>是唯一一个不等于自身的值。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/12/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(9)/" data-id="ckutzsf4d000t8spt3qiqakst" data-title="Javascript学习笔记(9)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Javascript%E7%AC%94%E8%AE%B0/" rel="tag">Javascript笔记</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Javascript学习笔记(8)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/10/12/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(8)/" class="article-date">
  <time class="dt-published" datetime="2021-10-12T05:59:35.000Z" itemprop="datePublished">2021-10-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/10/12/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(8)/">Javascript学习笔记(8)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ol>
<li><p><code>Object</code>对象的原生方法分成两类：<code>Object</code>本身的方法与<code>Object</code>的实例方法。</p>
<ul>
<li><strong><code>Object</code>对象本身的方法</strong>。所谓“本身的方法”就是直接定义在<code>Object</code>对象的方法。</li>
<li><strong><code>Object</code>的实例方法</strong>。所谓实例方法就是定义在<code>Object</code>原型对象<code>Object.prototype</code>上的方法。它可以被<code>Object</code>实例直接使用。</li>
</ul>
</li>
<li><p><code>instanceof</code>运算符用来验证，一个对象是否为指定的构造函数的实例。如果参数是原始类型的值，<code>Object</code>方法将其转为对应的包装对象的实例。如果<code>Object</code>方法的参数是一个对象，它总是返回该对象，即不用转换。利用这一点，可以写一个判断变量是否为对象的函数。</p>
</li>
<li><p><code>Object(value)</code>与<code>new Object(value)</code>两者的语义是不同的，<code>Object(value)</code>表示将<code>value</code>转成一个对象，<code>new Object(value)</code>则表示新生成一个对象，它的值是<code>value</code>。</p>
</li>
<li><p><code>Object.keys</code>方法只返回可枚举的属性，<code>Object.getOwnPropertyNames</code>方法还返回不可枚举的属性名。一般情况下，几乎总是使用<code>Object.keys</code>方法，遍历对象的属性。</p>
</li>
<li><p>实例方法：<code>valueOf</code>方法的作用是返回一个对象的“值”，默认情况下返回对象本身。<code>toString</code>方法的作用是返回一个对象的字符串形式，默认情况下返回类型字符串。</p>
</li>
<li><p>数组、字符串、函数、Date 对象都分别部署了自定义的<code>toString</code>方法，覆盖了<code>Object.prototype.toString</code>方法。直接使用<code>Object.prototype.toString</code>方法。通过函数的<code>call</code>方法，可以在任意值上调用这个方法，帮助我们判断这个值的类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(value)</span><br></pre></td></tr></table></figure></li>
<li><p>这个方法的主要作用是留出一个接口，让各种不同的对象实现自己版本的<code>toLocaleString</code>，用来返回针对某些地域的特定的值。Array,Number,Date的prototype自定义了<code>toLocaleString</code>方法。</p>
</li>
<li><p><code>Object.prototype.hasOwnProperty</code>方法接受一个字符串作为参数，返回一个布尔值，表示该实例对象自身是否具有该属性。</p>
</li>
<li><p>JavaScript 提供了一个内部数据结构，用来描述对象的属性，控制它的行为，比如该属性是否可写、可遍历等等。这个内部数据结构称为“属性描述对象”（attributes object）。</p>
</li>
<li><p>属性描述对象提供6个元属性。包括：value、writable(针对value)、enumerable、configurable(除value外其他元属性)、set、get。</p>
</li>
<li><p><code>Object.getOwnPropertyDescriptor()</code>方法可以获取属性描述对象。它的第一个参数是目标对象，第二个参数是一个字符串，对应目标对象的某个属性名。这一方法只能用于对象自身的属性，不能用于继承的属性。</p>
</li>
<li><p><code>Object.getOwnPropertyNames</code>方法返回一个数组，成员是参数对象自身的全部属性的属性名，不管该属性是否可遍历</p>
</li>
<li><p>注意，一旦定义了取值函数<code>get</code>（或存值函数<code>set</code>），就不能将<code>writable</code>属性设为<code>true</code>，或者同时定义<code>value</code>属性，否则会报错。</p>
</li>
<li><p><code>Object.defineProperty()</code>和<code>Object.defineProperties()</code>参数里面的属性描述对象，<code>writable</code>、<code>configurable</code>、<code>enumerable</code>这三个属性的默认值都为<code>false</code>。</p>
</li>
<li><p>实例对象的<code>propertyIsEnumerable()</code>方法返回一个布尔值，用来判断某个属性是否可遍历。注意，这个方法只能用于判断对象自身的属性，对于继承的属性一律返回<code>false</code>。</p>
</li>
<li><p><code>value</code>属性是目标属性的值。<code>writable</code>属性是一个布尔值，决定了目标属性的值（value）是否可以被改变。</p>
</li>
<li><p>如果原型对象的某个属性的<code>writable</code>为<code>false</code>，那么子对象将无法自定义这个属性。，有一个规避方法，就是通过覆盖属性描述对象，绕过这个限制。原因是这种情况下，原型链会被完全忽视。</p>
</li>
<li><p>具体来说，如果一个属性的<code>enumerable</code>为<code>false</code>，下面三个操作不会取到该属性。</p>
<ul>
<li><code>for..in</code>循环</li>
<li><code>Object.keys</code>方法</li>
<li><code>JSON.stringify</code>方法</li>
</ul>
<p>因此，<code>enumerable</code>可以用来设置“秘密”属性。</p>
</li>
<li><p>注意，<code>for...in</code>循环包括继承的属性，<code>Object.keys</code>方法不包括继承的属性。如果需要获取对象自身的所有属性，不管是否可遍历，可以使用<code>Object.getOwnPropertyNames</code>方法。</p>
</li>
<li><p>另外，<code>JSON.stringify</code>方法会排除<code>enumerable</code>为<code>false</code>的属性，有时可以利用这一点。如果对象的 JSON 格式输出要排除某些属性，就可以把这些属性的<code>enumerable</code>设为<code>false</code>。</p>
</li>
<li><p><code>configurable</code>为<code>false</code>时，<code>writable</code>、<code>enumerable</code>和<code>configurable</code>都不能被修改了。注意，<code>writable</code>属性只有在<code>false</code>改为<code>true</code>时会报错，<code>true</code>改为<code>false</code>是允许的。</p>
</li>
<li><p><code>value</code>属性的情况比较特殊。只要<code>writable</code>和<code>configurable</code>有一个为<code>true</code>，就允许改动<code>value</code>。可配置性决定了目标属性是否可以被删除（delete）。</p>
</li>
<li><p>注意，取值函数<code>get</code>不能接受参数，存值函数<code>set</code>只能接受一个参数（即属性的值）。存取器往往用于，属性的值依赖对象内部数据的场合。</p>
</li>
<li><p>对象的拷贝可以通过<code>Object.defineProperty</code>方法来拷贝属性。</p>
</li>
<li><p>有时需要冻结对象的读写状态，防止对象被改变。JavaScript 提供了三种冻结方法，最弱的一种是<code>Object.preventExtensions</code>，其次是<code>Object.seal</code>，最强的是<code>Object.freeze</code>。</p>
</li>
<li><p><code>Object.preventExtensions</code>方法可以使得一个对象无法再添加新的属性，也无法删除旧属性。<code>Object.isExtensible</code>方法用于检查一个对象是否使用了<code>Object.preventExtensions</code>方法。也就是说，检查是否可以为一个对象添加属性。</p>
</li>
<li><p><code>Object.seal</code>方法使得一个对象既无法添加新属性，也无法删除旧属性，并不影响修改某个属性的值。<code>Object.seal</code>实质是把属性描述对象的<code>configurable</code>属性设为<code>false</code>，因此属性描述对象不再能改变了。</p>
</li>
<li><p><code>Object.isSealed</code>方法用于检查一个对象是否使用了<code>Object.seal</code>方法。seal后，<code>Object.isExtensible</code>方法也返回<code>false</code>。</p>
</li>
<li><p><code>Object.freeze</code>方法可以使得一个对象无法添加新属性、无法删除旧属性、也无法改变属性的值，使得这个对象实际上变成了常量。</p>
</li>
<li><p>使用<code>Object.freeze</code>方法以后，<code>Object.isSealed</code>将会返回<code>true</code>，<code>Object.isExtensible</code>返回<code>false</code>。</p>
</li>
<li><p><code>Object.isFrozen</code>的一个用途是，确认某个对象没有被冻结后，再对它的属性赋值。</p>
</li>
<li><p>上面的三个方法锁定对象的可写性有一个漏洞：可以通过改变原型对象，来为对象增加属性。一种解决方案是，把<code>obj</code>的原型也冻结住。另外一个局限是，如果属性值是对象，上面这些方法只能冻结属性指向的对象，而不能冻结对象本身的内容。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/12/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(8)/" data-id="ckutzsf4b000r8spt2ct03nki" data-title="Javascript学习笔记(8)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Javascript%E7%AC%94%E8%AE%B0/" rel="tag">Javascript笔记</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Javascript学习笔记(7)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/10/11/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(7)/" class="article-date">
  <time class="dt-published" datetime="2021-10-11T09:36:57.000Z" itemprop="datePublished">2021-10-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/10/11/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(7)/">Javascript学习笔记(7)</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ol>
<li><p>强制转换主要指使用<code>Number()</code>、<code>String()</code>和<code>Boolean()</code>三个函数，手动将各种类型的值，分别转换成数字、字符串或者布尔值。</p>
</li>
<li><p><code>Number</code>函数将字符串转为数值，要比<code>parseInt</code>函数严格很多。基本上，只要有一个字符无法转成数值，整个字符串就会被转为<code>NaN</code>。</p>
</li>
<li><p><code>parseInt</code>逐个解析字符，而<code>Number</code>函数整体转换字符串的类型。<code>parseInt</code>和<code>Number</code>函数都会自动过滤一个字符串前导和后缀的空格。</p>
</li>
<li><p>简单的规则是，<code>Number</code>方法的参数是对象时，将返回<code>NaN</code>，除非是包含单个数值的数组。</p>
</li>
<li><p><code>String</code>方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。</p>
</li>
<li><p><code>String</code>方法背后的转换规则，与<code>Number</code>方法基本相同，只是互换了<code>valueOf</code>方法和<code>toString</code>方法的执行顺序。如果<code>toString</code>法和<code>valueOf</code>方法，返回的都是对象，就会报错。</p>
</li>
<li><p><code>Boolean()</code>函数可以将任意类型的值转为布尔值。</p>
<p>它的转换规则相对简单：除了以下五个值的转换结果为<code>false</code>，其他的值全部为<code>true</code>。</p>
<ul>
<li><code>undefined</code></li>
<li><code>null</code></li>
<li><code>0</code>（包含<code>-0</code>和<code>+0</code>）</li>
<li><code>NaN</code></li>
<li><code>&#39;&#39;</code>（空字符串）</li>
</ul>
</li>
<li><p>遇到以下三种情况时，JavaScript 会自动转换数据类型，即转换是自动完成的。</p>
<ul>
<li>不同类型的数据互相运算。</li>
<li>对非布尔值类型的数据求布尔值。</li>
<li>对非数值类型的值使用一元运算符（即<code>+</code>和<code>-</code>）。</li>
</ul>
</li>
<li><p>除了加法运算符（<code>+</code>）有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值。注意：<code>null</code>转为数值时为<code>0</code>，而<code>undefined</code>转为数值时为<code>NaN</code>。</p>
</li>
<li><p><code>Error</code>实例对象是最一般的错误类型，在它的基础上，JavaScript 还定义了其他6种错误对象。也就是说，存在<code>Error</code>的6个派生对象。</p>
<ul>
<li><code>SyntaxError</code>对象是解析代码时发生的语法错误。</li>
<li><code>ReferenceError</code>对象是引用一个不存在的变量时发生的错误。另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果赋值。</li>
<li><code>RangeError</code>对象是一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是<code>Number</code>对象的方法参数超出范围，以及函数堆栈超过最大值。</li>
<li><code>TypeError</code>对象是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用<code>new</code>命令，就会抛出这种错误，因为<code>new</code>命令的参数应该是一个构造函数。</li>
<li><code>URIError</code>对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及<code>encodeURI()</code>、<code>decodeURI()</code>、<code>encodeURIComponent()</code>、<code>decodeURIComponent()</code>、<code>escape()</code>和<code>unescape()</code>这六个函数。</li>
</ul>
</li>
<li><p><code>throw</code>语句的作用是手动中断程序执行，抛出一个错误。一旦发生错误，程序就中止执行了。JavaScript 提供了<code>try...catch</code>结构，允许对错误进行处理，选择是否往下执行。</p>
</li>
<li><p><code>try...catch</code>结构允许在最后添加一个<code>finally</code>代码块，表示不管是否出现错误，都必需在最后运行的语句。<code>return</code>语句的执行是排在<code>finally</code>代码之前，只是等<code>finally</code>代码执行完毕后才返回。</p>
</li>
<li><p>编程规范：</p>
<ul>
<li>表示区块起首的大括号，不要另起一行。</li>
<li>建议总是使用大括号表示区块。</li>
<li>由于解释引擎自动添加分号的行为难以预测，因此编写代码的时候不应该省略行尾的分号。</li>
<li>JavaScript 最大的语法缺点，可能就是全局变量对于任何一个代码块，都是可读可写。这对代码的模块化和重复使用，非常不利。因此，建议避免使用全局变量。如果不得不使用，可以考虑用大写字母表示变量名。</li>
<li>不要使用<code>with</code>语句。</li>
<li>建议不要使用相等运算符（<code>==</code>），只使用严格相等运算符（<code>===</code>）。</li>
<li>建议不要将不同目的的语句，合并成一行。</li>
<li>建议自增（<code>++</code>）和自减（<code>--</code>）运算符尽量使用<code>+=</code>和<code>-=</code>代替。</li>
<li>建议<code>switch...case</code>结构可以用对象结构代替。</li>
</ul>
</li>
<li><p><code>console.log</code>方法支持以下占位符，不同类型的数据必须使用对应的占位符。</p>
<ul>
<li><code>%s</code> 字符串</li>
<li><code>%d</code> 整数</li>
<li><code>%i</code> 整数</li>
<li><code>%f</code> 浮点数</li>
<li><code>%o</code> 对象的链接</li>
<li><code>%c</code> CSS 格式字符串</li>
</ul>
</li>
<li><p>可以这样理解，<code>log</code>方法是写入标准输出（<code>stdout</code>），<code>warn</code>方法和<code>error</code>方法是写入标准错误（<code>stderr</code>）。</p>
</li>
<li><p>对于某些复合类型的数据，<code>console.table</code>方法可以将其转为表格显示。<code>count</code>方法用于计数，输出它被调用了多少次.该方法可以接受一个字符串作为参数，作为标签，对执行次数进行分类。</p>
</li>
<li><p><code>dirxml</code>方法主要用于以目录树的形式，显示 DOM 节点。如果参数不是 DOM 节点，而是普通的 JavaScript 对象，<code>console.dirxml</code>等同于<code>console.dir</code>。</p>
</li>
<li><p><code>console.assert</code>方法主要用于程序运行过程中，进行条件判断，如果不满足条件，就显示一个错误，但不会中断程序执行。</p>
</li>
<li><p>console.time()，console.timeEnd() 这两个方法用于计时，可以算出一个操作所花费的准确时间。它们的参数是计时器的名称。</p>
</li>
<li><p><code>keys(object)</code>方法返回一个数组，包含<code>object</code>的所有键名。<code>values(object)</code>方法返回一个数组，包含<code>object</code>的所有键值。</p>
</li>
<li><p><code>debugger</code>语句主要用于除错，作用是设置断点。如果有正在运行的除错工具，程序运行到<code>debugger</code>语句时会自动停下。如果没有除错工具，<code>debugger</code>语句不会产生任何结果，JavaScript 引擎自动跳过这一句。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/10/11/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(7)/" data-id="ckutzsf46000p8spth5pjd1yt" data-title="Javascript学习笔记(7)" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Javascript%E7%AC%94%E8%AE%B0/" rel="tag">Javascript笔记</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS%E7%AC%94%E8%AE%B0/" rel="tag">CSS笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ES6%E9%98%AE%E4%B8%80%E5%B3%B0%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">ES6阮一峰教程学习笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Javascript%E7%AC%94%E8%AE%B0/" rel="tag">Javascript笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Typescript%E7%AC%94%E8%AE%B0/" rel="tag">Typescript笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E3%80%8Areact%E5%B0%8F%E4%B9%A6%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">《react小书》学习笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/" rel="tag">前端动画实现</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/" rel="tag">前端技术</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/" rel="tag">前端知识积累</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%BB%8F/" rel="tag">前端面经</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5/" rel="tag">字节青训营</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%89%9B%E5%AE%A2%E5%89%8D%E7%AB%AF%E9%A2%98/" rel="tag">牛客前端题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%87%AA%E7%94%A8%E8%AF%B4%E6%98%8E/" rel="tag">自用说明</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS%E7%AC%94%E8%AE%B0/" style="font-size: 20px;">CSS笔记</a> <a href="/tags/ES6%E9%98%AE%E4%B8%80%E5%B3%B0%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" style="font-size: 13.33px;">ES6阮一峰教程学习笔记</a> <a href="/tags/Javascript%E7%AC%94%E8%AE%B0/" style="font-size: 18.33px;">Javascript笔记</a> <a href="/tags/Typescript%E7%AC%94%E8%AE%B0/" style="font-size: 16.67px;">Typescript笔记</a> <a href="/tags/%E3%80%8Areact%E5%B0%8F%E4%B9%A6%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" style="font-size: 15px;">《react小书》学习笔记</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/" style="font-size: 10px;">前端动画实现</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/" style="font-size: 10px;">前端技术</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/" style="font-size: 11.67px;">前端知识积累</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%BB%8F/" style="font-size: 10px;">前端面经</a> <a href="/tags/%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5/" style="font-size: 10px;">字节青训营</a> <a href="/tags/%E7%89%9B%E5%AE%A2%E5%89%8D%E7%AB%AF%E9%A2%98/" style="font-size: 15px;">牛客前端题</a> <a href="/tags/%E8%87%AA%E7%94%A8%E8%AF%B4%E6%98%8E/" style="font-size: 10px;">自用说明</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/10/16/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(16)/">Javascript学习笔记(16)</a>
          </li>
        
          <li>
            <a href="/2021/10/15/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(15)/">Javascript学习笔记(15)</a>
          </li>
        
          <li>
            <a href="/2021/10/14/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(14)/">Javascript学习笔记(14)</a>
          </li>
        
          <li>
            <a href="/2021/10/14/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(13)/">Javascript学习笔记(13)</a>
          </li>
        
          <li>
            <a href="/2021/10/14/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(12)/">Javascript学习笔记(12)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>