<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Promises/A+标准翻译 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Promises&#x2F;A+为使用者提供可靠的、可协作的JavaScript Promises的一个开放标准 ​    一个promise表示一个异步操作的最终结果。和一个promise交互的主要方式是通过注册了回调函数的then方法，其中回调函数能够获取promise最终的值或者该promise无法执行的原因。 ​        此规范详述了提供了then方法的行为，所有遵循Promises&#x2F;A+规范">
<meta property="og:type" content="article">
<meta property="og:title" content="Promises&#x2F;A+标准翻译">
<meta property="og:url" content="http://example.com/2021/08/11/PromisesA+%E6%A0%87%E5%87%86%E7%BF%BB%E8%AF%91/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Promises&#x2F;A+为使用者提供可靠的、可协作的JavaScript Promises的一个开放标准 ​    一个promise表示一个异步操作的最终结果。和一个promise交互的主要方式是通过注册了回调函数的then方法，其中回调函数能够获取promise最终的值或者该promise无法执行的原因。 ​        此规范详述了提供了then方法的行为，所有遵循Promises&#x2F;A+规范">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-08-11T12:43:05.000Z">
<meta property="article:modified_time" content="2021-08-13T12:52:29.984Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="前端技术">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-PromisesA+标准翻译" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/11/PromisesA+%E6%A0%87%E5%87%86%E7%BF%BB%E8%AF%91/" class="article-date">
  <time class="dt-published" datetime="2021-08-11T12:43:05.000Z" itemprop="datePublished">2021-08-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Promises/A+标准翻译
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Promises-A"><a href="#Promises-A" class="headerlink" title="Promises/A+"></a>Promises/A+</h1><p><strong>为使用者提供可靠的、可协作的JavaScript Promises的一个开放标准</strong></p>
<p>​    一个promise表示一个异步操作的最终结果。和一个promise交互的主要方式是通过注册了回调函数的<code>then</code>方法，其中回调函数能够获取promise最终的值或者该promise无法执行的原因。</p>
<p>​        此规范详述了提供了<code>then</code>方法的行为，所有遵循Promises/A+规范的promise实现均可将本标准作为参照基础来实施<code>then</code>方法。因此此规范必须十分稳定。尽管Promises/A+组织可能偶尔做向后兼容的小小改变来修改这一规范，从而解决新发现的边界情况，我们只在谨慎地考虑、讨论和测试后，整合一些大的或是不向后兼容的变化。</p>
<p>​    从历史上看，Promises/A+阐明了更早的Promises/A建议的行为条例，将其扩展为包含实际上存在的行为，并且删减了在特殊情况下和有问题的部分。</p>
<p>​    最后，核心的Promises/A+规范不涉及处理如何创建，执行或是拒绝promise，而是选择聚焦于提供一个可协作的<code>then</code>方法。未来的其他规范可能会涉及到这些方面。</p>
<hr>
<h3 id="1-术语"><a href="#1-术语" class="headerlink" title="1.术语"></a>1.术语</h3><p>1.1. “promise”是一个具有<code>then</code>方法的对象或函数，其中<code>then</code>方法遵循此规范。</p>
<p>1.2. “thenable”是一个定义了<code>then</code>方法的对象或函数。</p>
<p>1.3. “value”是一个合法的Javascript值（包括<code>undefined</code>，一个thenable或是一个promise）。</p>
<p>1.4. “exception”是一个使用<code>throw</code>声明被丢弃的value。</p>
<p>1.5. “reason”是一个指明为什么一个promise被拒绝的value。</p>
<hr>
<h3 id="2-要求"><a href="#2-要求" class="headerlink" title="2.要求"></a>2.要求</h3><h4 id="2-1-Promise-状态"><a href="#2-1-Promise-状态" class="headerlink" title="2.1. Promise 状态"></a>2.1. Promise 状态</h4><p>一个promise必须在下列三种状态之一：pending(待决)，fulfilled(完成)或者rejected(拒绝)。</p>
<p>2.1.1. 当promise状态为pending:</p>
<p>​        2.1.1.1. 可能转换到fulfilled或者rejected状态。</p>
<p>2.1.2. 当promise状态为fulfilled：</p>
<p>​        2.1.2.1. 一定不会转换到任何其他状态。</p>
<p>​        2.1.2.2. 一定有一个不能改变的value。</p>
<p>2.1.3. 当promise状态为rejected时：</p>
<p>​        2.1.3.1. 一定不会转换到任何其他状态。</p>
<p>​        2.1.3.2. 一定有一个不能改变的reason。</p>
<p>这里的一定不会改变指的是不变恒等(===)，但不意味着深不变性。</p>
<h4 id="2-2-then-方法"><a href="#2-2-then-方法" class="headerlink" title="2.2 .  then 方法"></a>2.2 .  <code>then</code> 方法</h4><p>一个promise必须提供一个<code>then</code>方法来获取它当前或是最终的value或者reason。</p>
<p>一个promise的<code>then</code>方法接受两个参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.then(onFulfilled,onRejected)</span><br></pre></td></tr></table></figure>

<p>2.2.1. <code>onFulfilled</code>和<code>onRejected</code>都是可选参数：</p>
<p>​        2.2.1.1. 如果<code>onFulfilled</code>不是一个函数，它应当被忽略。</p>
<p>​        2.2.1.2. 如果<code>onRejected</code>不是一个函数，它应当被忽略。</p>
<p>2.2.2. 如果<code>onFulfilled</code>是一个函数：</p>
<p>​        2.2.2.1. 它一定在<code>promise</code> fulfilled后才被调用，将<code>promise</code>的value作为其第一个参数。</p>
<p>​        2.2.2.2. 它一定不会在<code>promise</code> fulfilled前被调用。</p>
<p>​        2.2.2.3. 它的调用次数不会超过一次。</p>
<p>2.2.3.  如果<code>onRejected</code>是一个函数：</p>
<p>​        2.2.3.1. 它一定在<code>promise</code> rejected后才被调用，将<code>promise</code>的reason作为其第一个参数。</p>
<p>​        2.2.3.2. 它一定不会在<code>promise</code> rejected前被调用。</p>
<p>​        2.2.3.3. 它的调用次数不会超过一次。</p>
<p>2.2.4. <code>onFulfilled</code> 或者<code>onRejected</code>当且仅当<a target="_blank" rel="noopener" href="https://es5.github.io/#x10.3">执行环境</a>堆栈只包含平台代码时可以被调用。[见3.1]</p>
<p>2.2.5. <code>onFulfilled</code>和<code>onRejected</code>必须以函数的方式被调用(例如：不包含<code>this</code> value)。</p>
<p>2.2.6. <code>then</code>在同一个promise中可能被多次调用。</p>
<p>​        2.2.6.1. 如果/当<code>promise</code>被fulfilled后，所有相应的<code>onFulfilled</code>调用必须按照对<code>then</code>原始调用的顺序        执行。</p>
<p>​        2.2.6.2. 如果/当<code>promise</code>被rejected后，所有相应的<code>onFulfilled</code>调用必须按照对<code>then</code>原始调用的顺        序执行。</p>
<p>2.2.7. <code>then</code>必须返回一个promise。[见3.3]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise2=promise1.then(onFulfilled,onRejected);</span><br></pre></td></tr></table></figure>

<p>​        2.2.7.1. 如果<code>onFulfilled</code>或者<code>onRejected</code>返回一个value <code>x</code>，执行以下promise解决过程：</p>
<p>​        [[Resolve]](promise2,x)</p>
<p>​        2.2.7.2. 如果<code>onFulfilled </code>或者<code>onRejected</code>抛出一个 exception  <code>e</code>，<code>promise2</code>必须以<code>e</code>为reason来被rejected。</p>
<p>​        2.2.7.3. 如果<code>onFulfilled</code>不是一个函数，同时<code>promise1</code>被fulfilled，<code>promise2</code>必须使用和<code>promise1</code>相同的value被fulfilled。</p>
<p>​        2.2.7.4. 如果<code>onRejected</code>不是一个函数，同时<code>promise1</code>被fulfilled，<code>promise2</code>必须使用和<code>promise1</code>相同的value被rejected。</p>
<h4 id="2-3-Promise解决过程"><a href="#2-3-Promise解决过程" class="headerlink" title="2.3 Promise解决过程"></a>2.3 Promise解决过程</h4><p>promise解决过程表示为<code>[[Resolve]](promise,x)</code>，是以一个promise和一个value为输入的抽象操作。如果<code>x</code>是thenable的，同时x表现的有些像一个promise，那么解决过程试图让<code>promise</code>接受<code>x</code>的状态。否则，解决过程用value <code>x</code>来fulfill promise。</p>
<p>只要promise的实现暴露了一个遵循Promises/A+的<code>then</code>方法，这种thenable的特性就会使得promise的实现更具通用性，同时使得遵循了Promises/A+的promise实现能和未遵循但有可用<code>then</code>方法的promise实现共存。</p>
<p>为了运行<code>[[Resolve]](promise,x)</code>，执行以下步骤：</p>
<p>2.3.1. 如果<code>promise</code>和<code>x</code>指向同一个对象，那么以<code>TypeError</code>作为reason来reject <code>promise</code>。</p>
<p>2.3.2 如果<code>x</code>是一个promise，接受它的状态[见3.4]：</p>
<p>​        2.3.2.1. 如果<code>x</code>处于pending状态时，在<code>x</code>处于fulfilled或者rejected状态之前，<code>promise</code>必须一直保持        pending状态。</p>
<p>​        2.3.2.2. 如果/当<code>x</code>处于fulfilled状态时，使用同样的value来fulfill <code>promise</code>。</p>
<p>​        2.3.2.3. 如果/当<code>x</code>处于rejected状态时，使用同样的reason来reject <code>promise</code>。</p>
<p>2.3.3. 如果<code>x</code>是一个对象或者函数，</p>
<p>​        2.3.3.1. 让<code>then</code>变为<code>x.then</code>[见3.5]</p>
<p>​        2.3.3.2. 如果取<code>x.then</code>的值导致了一个exception <code>e</code>的抛出，将<code>e</code>作为reason来reject <code>promise</code>。</p>
<p>​        2.3.3.3. 如果<code>then</code>是一个函数，将<code>x</code>作为<code>this</code>来调用它，第一个参数为<code>resolvePromise</code>，第二个参        数为<code>rejectPromise</code>，其中：</p>
<p>​            2.3.3.3.1. 如果/当<code>resolvePromise</code>被一个value <code>y</code>调用，运行<code>[[Resolve]](promise,y)</code>.</p>
<p>​            2.3.3.3.2. 如果/当rejectPromise被一个reason <code>r</code>调用，用<code>r</code>来reject <code>promise</code>。</p>
<p>​            2.3.3.3.3.  如果<code>resolvePromise</code>和<code>rejectPromise</code>都被调用或者对同一参数进行了多次调用，则第            一次调用优先，其他所有调用都被忽略。</p>
<p>​            2.3.3.3.4. 如果调用<code>then</code>抛出了一个exception <code>e</code>，</p>
<p>​                2.3.3.3.4.1 如果<code>resolvePromise</code>或者<code>rejectPromise</code>已经被调用过了，则无视。</p>
<p>​                2.3.3.3.4.2. 否则，以<code>e</code>为reason来reject <code>promise</code>。</p>
<p>​        2.3.3.4. 如果<code>then</code>不是一个函数，用<code>x</code>来fulfill <code>promise</code>。</p>
<p>2.3.4. 如果<code>then</code>不是一个对象或函数，用<code>x</code>来fulfill <code>promise</code>。</p>
<p>如果一个promise使用参与了一个循环thenable链的thenable变为resolved，例如<code>[[Resolve]](promise,thenable)</code>的循环性质最终导致<code>[[Resolve]](promise,thenable)</code>被再次调用，遵循上述算法将导致无限递归。鼓励但不强制要求实现检测这样的递归，并以提示信息的<code>TypeError</code> 作为reason来reject <code>promise</code>。</p>
<h3 id="3-注释"><a href="#3-注释" class="headerlink" title="3.注释"></a>3.注释</h3><p>3.1. 这里的平台代码指引擎，环境和promise的实现代码。实际上，这个要求确保了在<code>then</code>被调用的那一轮事件循环之后的新栈中，<code>onFulfilled</code>和<code>onRejected</code>异步执行。可以使用例如<code>setTimeout</code>或<code>setImmediate</code>的宏任务机制，或者例如<code>MutationObserver</code>或<code>process.nextTick</code>的微任务机制来实现。由于promise实现本身就是平台代码，可能自身已经包含了一个在其中调用处理程序的任务调度队列。</p>
<p>3.2. 在严格模式下，它们的<code>this</code>是<code>undefined</code>;在非严格模式下，它是一个全局对象。</p>
<p>3.3. 在满足所有要求的情况下实现可能允许<code>promise1===promise2</code>，每个实现都应记录是否允许以及在什么条件下允许<code>promise2===promise1</code>。</p>
<p>3.4. 通常，只有在<code>x</code>符合当前实现时，我们才认为它是真正的promise。这一条款允许那些特定实现方式接受已知符合要求的promises状态。</p>
<p>3.5. 这一步首先存储了对<code>x.then</code>的引用，接着测试了这个引用，随后调用这个引用，避免对于<code>x.then</code>属性的多次访问。这一预防措施对于确保访问器属性的一致性非常重要，因为访问器属性值可能在检索间改变。</p>
<p>3.6. 实现在thenable链的深度上不应该设置任意限制，并假定超出这一任意限制后将无限递归。只有真正的循环应该导致一个<code>TypeError</code>；如果遇到了一条无限长的链上thenable各不相同，正确的行为是一直递归下去。</p>
<hr>
<p>翻译此标准是为了便于自己后续的实现，同时加深对于Promises/A+标准的理解。按个人阅读习惯，在翻译中保留了一些在标准中解释过的专有术语。个人水平不足，翻译可能存在一些问题，若有不当之处还望指正，谢谢！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/11/PromisesA+%E6%A0%87%E5%87%86%E7%BF%BB%E8%AF%91/" data-id="ckutzsf4e000x8sptfk5mf1d1" data-title="Promises/A+标准翻译" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/" rel="tag">前端技术</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/08/18/Typescript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(1)/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Typescript学习笔记(1)
        
      </div>
    </a>
  
  
    <a href="/2021/08/11/%E3%80%8ACSS%E4%B8%96%E7%95%8C%E3%80%8B%E7%AC%94%E8%AE%B0(1)/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">《CSS世界》笔记(1)</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS%E7%AC%94%E8%AE%B0/" rel="tag">CSS笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ES6%E9%98%AE%E4%B8%80%E5%B3%B0%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">ES6阮一峰教程学习笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Javascript%E7%AC%94%E8%AE%B0/" rel="tag">Javascript笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Typescript%E7%AC%94%E8%AE%B0/" rel="tag">Typescript笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E3%80%8Areact%E5%B0%8F%E4%B9%A6%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">《react小书》学习笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/" rel="tag">前端动画实现</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/" rel="tag">前端技术</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/" rel="tag">前端知识积累</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%BB%8F/" rel="tag">前端面经</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5/" rel="tag">字节青训营</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%89%9B%E5%AE%A2%E5%89%8D%E7%AB%AF%E9%A2%98/" rel="tag">牛客前端题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%87%AA%E7%94%A8%E8%AF%B4%E6%98%8E/" rel="tag">自用说明</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS%E7%AC%94%E8%AE%B0/" style="font-size: 20px;">CSS笔记</a> <a href="/tags/ES6%E9%98%AE%E4%B8%80%E5%B3%B0%E6%95%99%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" style="font-size: 13.33px;">ES6阮一峰教程学习笔记</a> <a href="/tags/Javascript%E7%AC%94%E8%AE%B0/" style="font-size: 18.33px;">Javascript笔记</a> <a href="/tags/Typescript%E7%AC%94%E8%AE%B0/" style="font-size: 16.67px;">Typescript笔记</a> <a href="/tags/%E3%80%8Areact%E5%B0%8F%E4%B9%A6%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" style="font-size: 15px;">《react小书》学习笔记</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E5%8A%A8%E7%94%BB%E5%AE%9E%E7%8E%B0/" style="font-size: 10px;">前端动画实现</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/" style="font-size: 10px;">前端技术</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/" style="font-size: 11.67px;">前端知识积累</a> <a href="/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E7%BB%8F/" style="font-size: 10px;">前端面经</a> <a href="/tags/%E5%AD%97%E8%8A%82%E9%9D%92%E8%AE%AD%E8%90%A5/" style="font-size: 10px;">字节青训营</a> <a href="/tags/%E7%89%9B%E5%AE%A2%E5%89%8D%E7%AB%AF%E9%A2%98/" style="font-size: 15px;">牛客前端题</a> <a href="/tags/%E8%87%AA%E7%94%A8%E8%AF%B4%E6%98%8E/" style="font-size: 10px;">自用说明</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/10/16/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(16)/">Javascript学习笔记(16)</a>
          </li>
        
          <li>
            <a href="/2021/10/15/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(15)/">Javascript学习笔记(15)</a>
          </li>
        
          <li>
            <a href="/2021/10/14/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(14)/">Javascript学习笔记(14)</a>
          </li>
        
          <li>
            <a href="/2021/10/14/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(13)/">Javascript学习笔记(13)</a>
          </li>
        
          <li>
            <a href="/2021/10/14/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(12)/">Javascript学习笔记(12)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>